import{r as m,u as x,j as e}from"./index-DRLOKyBb.js";import{u as p}from"./useQuery-B7AxrqEf.js";import{u as j}from"./useMutation-DHs8FGCZ.js";import{D as y}from"./DescriptionBox-Dj_QFhWr.js";import"./useBaseQuery-B8Kr4lM1.js";const g=async()=>(await new Promise(t=>setTimeout(t,1e3)),"Hello from Tanstack Query!"),f=async t=>(await new Promise(n=>setTimeout(n,500)),console.log("Simulating post with:",t),{success:!0,message:`Data '${t}' posted successfully!`}),_="_container_1eqfj_1",q="_descriptionColumn_1eqfj_17",T="_exampleColumn_1eqfj_27",v="_heading_1eqfj_43",b="_subHeading_1eqfj_55",D="_dataDisplay_1eqfj_71",N="_inputGroup_1eqfj_87",C="_inputField_1eqfj_101",w="_button_1eqfj_131",Q="_loadingText_1eqfj_173",E="_errorText_1eqfj_183",P="_successText_1eqfj_201",s={container:_,descriptionColumn:q,exampleColumn:T,heading:v,subHeading:b,dataDisplay:D,inputGroup:N,inputField:C,button:w,loadingText:Q,errorText:E,successText:P},H=()=>{var o;const[t,n]=m.useState(""),c=x(),{data:l,error:r,isLoading:d,isFetching:u}=p({queryKey:["basicData"],queryFn:g,staleTime:30*1e3}),a=j({mutationFn:f,onSuccess:i=>{c.invalidateQueries({queryKey:["basicData"]}),console.log("Mutation successful:",i.message),n("")},onError:i=>{console.error("Mutation failed:",i.message)}}),h=()=>{t.trim()&&a.mutate(t)};return d?e.jsx("div",{className:s.container,children:e.jsx("div",{className:s.loadingText,children:"Loading query data..."})}):r instanceof Error?e.jsx("div",{className:s.container,children:e.jsxs("div",{className:s.errorText,children:["Query error: ",r.message]})}):e.jsxs("div",{className:s.container,children:[e.jsx("div",{className:s.descriptionColumn,children:e.jsxs(y,{title:"useQuery, useMutation, and Invalidation",children:[e.jsx("p",{children:"This example demonstrates the fundamental hooks of React Query:"}),e.jsxs("ul",{children:[e.jsxs("li",{children:[e.jsx("code",{children:"useQuery"}),": Used to fetch data (",e.jsx("code",{children:"fetchData"})," API call). It automatically handles loading states, error states, and caching. The ",e.jsx("code",{children:"queryKey"})," (",e.jsx("code",{children:"['basicData']"}),") uniquely identifies this query's data in the cache. We've also set a"," ",e.jsx("code",{children:"staleTime"})," of 30 seconds, meaning the data won't be automatically refetched on mount or window focus within that period unless invalidated."]}),e.jsxs("li",{children:[e.jsx("code",{children:"useMutation"}),": Used to modify data on the server (simulated by ",e.jsx("code",{children:"postData"}),"). It provides status states like ",e.jsx("code",{children:"isPending"}),","," ",e.jsx("code",{children:"isError"}),", ",e.jsx("code",{children:"isSuccess"}),"."]}),e.jsxs("li",{children:[e.jsx("code",{children:"queryClient.invalidateQueries()"}),": Called in the ",e.jsx("code",{children:"onSuccess"})," callback of the mutation. This marks the query associated with"," ",e.jsx("code",{children:"['basicData']"})," as stale, prompting React Query to refetch it automatically to keep the UI synchronized with the (simulated) server state."]})]})]})}),e.jsxs("div",{className:s.exampleColumn,children:[e.jsx("h1",{className:s.heading,children:"Tanstack Query Basics (with staleTime)"}),e.jsxs("p",{children:[e.jsx("strong",{children:"Fetched Data:"})," ",u?"(Fetching...)":""]}),e.jsx("div",{className:s.dataDisplay,children:l}),e.jsx("h2",{className:s.subHeading,children:"Simulate Posting Data"}),e.jsxs("div",{className:s.inputGroup,children:[e.jsx("input",{type:"text",value:t,onChange:i=>n(i.target.value),placeholder:"Enter data to post",className:s.inputField,disabled:a.isPending}),e.jsx("button",{onClick:h,className:s.button,disabled:a.isPending||!t.trim(),type:"button",children:a.isPending?"Posting...":"Post Data"})]}),a.isError&&e.jsxs("div",{className:s.errorText,children:["Mutation Error:"," ",a.error instanceof Error?a.error.message:"An unknown error occurred"]}),a.isSuccess&&e.jsx("div",{className:s.successText,children:(o=a.data)==null?void 0:o.message})]})]})};export{H as BasicQueryExample};
