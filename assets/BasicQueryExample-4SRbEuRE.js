import{r as m,u as x,j as e}from"./index-CROjpMMh.js";import{u as p}from"./useQuery-DxaqZLb7.js";import{u as y}from"./useMutation-xFXGLL8l.js";import{D as g}from"./DescriptionBox-mZa1W4Jk.js";import"./useBaseQuery-yCOZ2zrK.js";const j=async()=>(await new Promise(t=>setTimeout(t,1e3)),"Hello from React Query!"),w=async t=>(await new Promise(i=>setTimeout(i,500)),console.log("Simulating post with:",t),{success:!0,message:`Data '${t}' posted successfully!`}),_="_container_nwbwn_1",b="_descriptionColumn_nwbwn_17",f="_exampleColumn_nwbwn_27",T="_heading_nwbwn_43",v="_subHeading_nwbwn_55",D="_dataDisplay_nwbwn_71",N="_inputGroup_nwbwn_87",C="_inputField_nwbwn_101",q="_button_nwbwn_131",Q="_loadingText_nwbwn_173",E="_errorText_nwbwn_183",P="_successText_nwbwn_201",s={container:_,descriptionColumn:b,exampleColumn:f,heading:T,subHeading:v,dataDisplay:D,inputGroup:N,inputField:C,button:q,loadingText:Q,errorText:E,successText:P},H=()=>{var o;const[t,i]=m.useState(""),c=x(),{data:l,error:r,isLoading:d,isFetching:u}=p({queryKey:["basicData"],queryFn:j,staleTime:30*1e3}),n=y({mutationFn:w,onSuccess:a=>{c.invalidateQueries({queryKey:["basicData"]}),console.log("Mutation successful:",a.message),i("")},onError:a=>{console.error("Mutation failed:",a.message)}}),h=()=>{t.trim()&&n.mutate(t)};return d?e.jsx("div",{className:s.container,children:e.jsx("div",{className:s.loadingText,children:"Loading query data..."})}):r instanceof Error?e.jsx("div",{className:s.container,children:e.jsxs("div",{className:s.errorText,children:["Query error: ",r.message]})}):e.jsxs("div",{className:s.container,children:[e.jsx("div",{className:s.descriptionColumn,children:e.jsxs(g,{title:"useQuery, useMutation, and Invalidation",children:[e.jsx("p",{children:"This example demonstrates the fundamental hooks of React Query:"}),e.jsxs("ul",{children:[e.jsxs("li",{children:[e.jsx("code",{children:"useQuery"}),": Used to fetch data (",e.jsx("code",{children:"fetchData"})," API call). It automatically handles loading states, error states, and caching. The ",e.jsx("code",{children:"queryKey"})," (",e.jsx("code",{children:"['basicData']"}),") uniquely identifies this query's data in the cache. We've also set a"," ",e.jsx("code",{children:"staleTime"})," of 30 seconds, meaning the data won't be automatically refetched on mount or window focus within that period unless invalidated."]}),e.jsxs("li",{children:[e.jsx("code",{children:"useMutation"}),": Used to modify data on the server (simulated by ",e.jsx("code",{children:"postData"}),"). It provides status states like ",e.jsx("code",{children:"isPending"}),","," ",e.jsx("code",{children:"isError"}),", ",e.jsx("code",{children:"isSuccess"}),"."]}),e.jsxs("li",{children:[e.jsx("code",{children:"queryClient.invalidateQueries()"}),": Called in the ",e.jsx("code",{children:"onSuccess"})," callback of the mutation. This marks the query associated with"," ",e.jsx("code",{children:"['basicData']"})," as stale, prompting React Query to refetch it automatically to keep the UI synchronized with the (simulated) server state."]})]})]})}),e.jsxs("div",{className:s.exampleColumn,children:[e.jsx("h1",{className:s.heading,children:"React Query Basics (with staleTime)"}),e.jsxs("p",{children:[e.jsx("strong",{children:"Fetched Data:"})," ",u?"(Fetching...)":""]}),e.jsx("div",{className:s.dataDisplay,children:l}),e.jsx("h2",{className:s.subHeading,children:"Simulate Posting Data"}),e.jsxs("div",{className:s.inputGroup,children:[e.jsx("input",{type:"text",value:t,onChange:a=>i(a.target.value),placeholder:"Enter data to post",className:s.inputField,disabled:n.isPending}),e.jsx("button",{onClick:h,className:s.button,disabled:n.isPending||!t.trim(),type:"button",children:n.isPending?"Posting...":"Post Data"})]}),n.isError&&e.jsxs("div",{className:s.errorText,children:["Mutation Error:"," ",n.error instanceof Error?n.error.message:"An unknown error occurred"]}),n.isSuccess&&e.jsx("div",{className:s.successText,children:(o=n.data)==null?void 0:o.message})]})]})};export{H as BasicQueryExample};
